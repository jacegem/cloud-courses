AWS 서비스, 서버리스 프레임워크 소개부터 서버리스 애플리케이션 개발과 배포까지

### 예제 코드 다운로드
https://github.com/PacktPublishing/Building-Serverless-Web-Applications

### 컬러 이미지 다운로드
Https://www.packtpub.com/sites/default/files/downloads/BuildingServerlessWebApplications_ColorImagges.pdf

# 01장 서버리스 모델의 이해
## 서버리스 개요
### 서버리스에 관해
데브옵스는 개발자가 프로그래밍하고, 빌드하고, 직접 시스템에 배포도 하고 서비스하면서 지속적으로 개선해 나가는 것을 의미한다. 서버와 개발 기술뿐 아니라 지속적 통합과 배포(CI/CD), 테스트, 데이터베이스 관리 같은 운영상의 문제도 해결할 수 있어야 한다.

1. 사용자는 클라우드 서비스 공급자가 제공한 주소로 요청을 전송한다.
2. 크랄우드 서비스는 메시지를 기반으로 요청에 응답하는 데 사용할 패키지를 찬느다.
3. 패키지(또는 기능)가 선택되면 패키지를 실행할 도커 컨테이너로 로드한다.
4. 도커 컨테이너가 실행되고 요청이 처리된다.
5. 생성된 응답을 요청한 사용자에게 전송한다.

### 서버리스의 주요 목적
* 필요한 만큼 확장: 과다 또는 과잉 프로비저닝이 없어야 한다.
* 고가용성: 내결합성(fault tolerant)이있으며 항상 온라인 상태여야 한다.
* 비용 효율성: 유휴 서버에 대해서는 비용을 지불하지 않는다.

람다(AWS Lambda)는 이벤트가 발생하면 코드를 선택하고 실행하는 서버리스 서비스다. 람다는 아마존 API 게이트웨이(Amazon API Gateway)를 통한 HTTP 요청, 다이나모(DynamoDB)에 DML 요청 등 다양한 이벤트 코드를 자동으로 실행한다. 개발자는 코드만 제공하면 된다.

## 서버리스의 장점과 단점
### 서버리스의 장점
* 빠른 확장성
* 고가용성
* 자원의 효율적 사용
* 운영 비용 절감
* 인프라가 아닌, 업무에 집중
* 시스템 보안의 아웃소싱
* 지속적인 배포(CI/CD)
* 마이크로서비스에 적합한 기술
* 스타트업 기업에 유리한 비용 모델

### 서버리스의 단점
* 긴 대기 시간
* 제약 조건
* 숨겨진 비효율성
* 공급업체 종속성
* 어려운 디버깅
* 원자 단위 배포
* 불확실성

### 피해야 할 것들
* 장시간 실행되는 CPU를 많이 사용하는 작업
* 지속적이며 예측 가능한 트래픽 처리
* 실시간 처리
* 멀티플레이어 게임

# 02 AWS로 시작하기
### AWS 클라우드포메이션
클라우드포메이션(CloudFormation)은 개발자가 템플릿을 사용해 전체 인프라를 스크립팅 할 수 있는 가능성을 제공한다. 이 접근법은 IaaC(Infrastructure as a Code)라 불린다.
Https://aws.amazon.com/ko/cloudformation/aws-cloudformation-templates/

### 아마존 클라우드워치

클라우드워치(CloudWatch)는 AWS 자원을 모니터링하는 서비스다. 대부분 가상머신을 모니터링하는 데 사용되지만, 가상머신 외에도 서버리스 기능에 기반한 운영을 모니터링하는 경우에도 중요한 역할을 한다.

### AWS IoT

AWS IoT는 MQTT(Message Queuing Telemetry Transport) 프로토콜을 사용해 게시-구독 패턴을 구현한다.
MQTT는 경량의 publish/Subscribe 메시지 프로토콜을 저전력, 낮은 대역폭 환경에서도 사용할 수 있도록 설계돼 소형기기와 제어와 센서 정보 수집에 많이 사용되고 있다.

# 03장 서버리스 프레임워크

서버리스 프레임워크는 클라우드 서비스가 아닌 강력한 Node.js 명령줄 도구다.
프레임워크의 목적은 개발자가 생산성을 높일 수 있게 클라우드 자원을 사용하고 관리하는 방법을 단순화하는 데 있다.
프레임워크를 활용하면 새로운 프로젝트를 빠르게 시작하고, 기능 추가, 엔드포인트, 트리거를 추가하고, 사용 권한을 구성하는 등의 작업을 신속하게 할 수 있는 일련의 명령을 제공받을 수 있다.
정리하면 프레임워크는 코드 배포를 자동화하며 다양한 서비스와 통합하는 등의 프로젝트를 관리하는 것이다.

서버리스 프레임워크의 입력으로 활용될 수 있는 것은 다음과 같다.
* 통합(Integration): 여러 클라우드 서비스가 람다 함수를 트리거하는 방법과 내용을 설명
* 구성(Configuration): 람다 함수의 사용 권한 설정과 실행 환경의 제한(제한 시간, RAM 메모리) 정의
* 플러그(Plugin)인: 사용자 정의 코드를 이용한 프레임워크 기능 확장

다음은 입력 결과로 프레임워크가 제공하는 것들이다.
* 아키텍처(Architecture): 프로젝트를 일관성 있게 유지할 아키텍처 정의 지원
* 배포(Deploy): 코드 배포 자동화, 하나의 명령으로 언제든지 배포 가능
* 버저닝(Versioning): 인프라의 버전을 의미하는 코드 구성의 버저닝 지원. 동일한 인프라를 다른 지역이나 환경으로 복제하는 것은 쉬운 일이 아니다.

https://github.com/anaibol/awesome-serverless

고(Go)는 자바와 C 등의 언어들보다 좀 더 빠르고 사용이 쉬우며, 프로그래밍 편의성과 검파일된 언어의 효율성과 안전성을 가진 프로그래밍 언어로 페이스북, 도커 등에서 사용되고 있다. 러스트(Rust)는 모질라(Mozilla)가 개발한 C 나 C++과 유사하며 성능, 병해화, 메모리 안전성에 초점을 둔 새로운 프로그래밍 언어다. 클로저(Clojure)는 리스프(Lisp) 프로그래밍 언어로, 함수 프로그래밍에 중점을 둔 언어로 월마트, 퍼펫 랩스 등에서 사용되고 있다.

### 프레임워크 설치

```shell
npm install serverless@1.x --global
serverless --version
serverless create --template aws-nodejs --name hello-serverless
```

명령을 실행하면 다음 두 개의 파일이 생성된다.
* handler.js 
* serverless.yml

YAML은 YAML Ain't Markup Language의 재귀적 약어로, 사람이 조금 더 잘 읽을 수 있는 것을 목표로 한다.

```yaml
service: hello-serverless

provider:
	name: aws
	runtime: nodejs6.10
	
functions:
	hello:
		handler: handler.hello
```

- service: 서비스를 생성하는 동안 지정한 서비스 이름이다.
- provider: 클라우드 공급자와 런타임을 설정한다. AWS와 최신 Node.js 버전을 선택했다.
- functions: 람다 함수를 정의하고 설정한다.

### 이벤트

서버리스 프레임워크는 현재 다음 이벤트를 지원한다.

- 아마존 API 게이트웨이: HTTP 메시지를 통해 람다 함수를 트리거하여 RESTful 인터페이스를 생성한다.
- 아마존 S3: 새 파일을 추가하거나 파일 제거 작업을 수행할 때 사후 처리를 위한 함수를 트리거한다.
- 아마존 SNS: 람다 함수를 이용해 SNS 알림을 처리한다.
- 일정: 예약된 작업을 기반으로 함수를 트리거한다.
- 아마존 다이나모DB: 테이블에 새 항목이 추가될 때 함수를 트리거한다.
- 아마존 키네시스(Kinesis): 람다 함수를 이용해 키네시스 스트림을 처리한다.
- 아마존 알렉사(Alexa): 알렉사 기능으로 함수를 트리거한다.
- AWS IoT: IoT 주제에 메시지 전송을 처리한다.
- 아마존 클라우드워치: 클라우드워치 이벤트를 처리하고 람다 함수를 사용해 메시지를 기록한다.

공식문서: https://serverless.com/framework/docs/providers/aws/events/

### 스캐폴딩

스캐폴딩(Scaffolding)은 일반적인 문제에 대한 샘플 솔루션을 제공해 개발자를 돕는 기술이다. 표준을 사용해 신규 프로젝트를 구축하면 일부 기능이 이미 구성, 개발, 잘 테스트된 것을 활용할 수 있는 장점이 있다.

https://github.com/serverless/examples

```shell
$ serverless install --url https://github.com/zanonio/serverless-store
```

# 04장 웹사이트 호스팅

- 아마존  S3를 이용한 정적 파일 호스팅
- 도메인 네임과 S3을 연동하기 위한 루트53 설정
- CDN을 통해 파일을 제공하기 위한 클라우트프론트 사용
- HTTPS 통신 사용을 위한 무료 SSL/TLS 인증서 요청

## www 앵커

www 앵커(anchor) 없는 도메인 네임은 보통 네이키드(naked) 도메인으로 불린다. www.example.com 은 www 앵커가 있는 도메인이고, example.com 은 네이키드 도메인이다. 어떤 형식의 주소를 메인 주소로 사용할지는 선택 사항이다.

### 웹사이트 자동 배포

```shell
aws s3 sync ./path/to/folder s3://my-bucket-name --acl public-read
```

### gzip 사용

gzip 파일 포맷은 파일 압축을 통해 전송되는 파일 크기를 줄여서 다운로드 속도를 향상 시키기 위해 사용되는 표준 포맷이다.

### HTTPS 지원 설정

1. 루트 53에 메일 익스체인지 레코드를 생성한다.
2. AWS에 무료 SSL/TLS 인증서 발급을 요청한다.
3. 새로운 인증서를 사용할 수 있도록 클라우드프론트 배포 설정을 수정한다.

# 05 프론트엔드 구축

## SPA

장점

- 페이지 새로 고침 없음
- 결합도 감소
- 서버측 코드 줄이기

단점

- 더 큰 파일 크기
- 자바스크립트 필요
- 검색 엔진 최적화

## 사전 렌더링 페이지

http://phamtomjs.org

## 온라인 상점 구축

- 홈페이지
- 제품 상세 페이지
- 장바구니 페이지
- 가입 페이지
- 로그인 페이지
- 찾을 수 없는 페이지
- 오류 페이지

https://github.com/zanon-io/serverless-store

 https://stripe.com

# 06 백엔드 개발

## 프로젝트 아키텍처 정의

- 나노서비스(Nanoservices): 각 기능마다 각자의 람다 함수가 있다.
- 마이크로 서비스(Microservices): 각 람다가 단일 자원의 모든 HTTP 요청을 처리한다.
- 모놀리스(Monolith): 모놀리스는 하나의 람다 함수가 모든 기능들을 처리한다.
- 그래프(Graph): 그래프는 REST API의 대안인 그래프QL 표준을 사용한다.

### 모놀리스와 마이크로서비스의 차이

마이크로서비스의 장점

- 관심사와 모듈성의 분리 개선
- 독립적인 수시 배포
- 팀을 분리해 좀 더 수월하게 개발

단점

- 더 많은 데브옵스 노력(서버리스 프레임워크에 의해 완화될 수 있음)
- 분산된 시스템은 더 복잡합
- 여러 서비스 간의 통합 테스트 어려움

### 나노서비스

장점

- 관심사의 분리(aspect)는 시스템의 다른 부분에 영향을 주지 않고 기능 하나를 수정할 수 있다. 자율 운영팀은 갈등을 최소화할 수 있는 혜택을 얻는다.
- 함수가 단일 책임을 가지면 문제를 디버깅하는 것이 훨씬 쉽다.

단점

- 성능이 저하될 수 있다. 일부 기능이 거의 트리거되지 않기 때문에 콜드 시작 지연이 더 자주 발생한다.
- 큰 프로젝트에서는 수백 가지 기능을 사용할 수 있다. 거대한 수의 논리적 부분이 있다면 혜택보다는 불이익이 많다.

### 마이크로서비스

장점

- 관리할 람다 함수의 수를 줄일 수 있다.
- 콜드 스타트가 적으면 성능이 나노서비스보다 약간 더 좋을 수 있다.

단점

- 각 함수에는 더 많은 옵션과 가능한 결과가 있기 때문에 디버깅은 조금 더 복잡하다.
- 각 요청을 올바르게 처리하려면 라우팅 메커니즘을 구현해야 한다.

### 모놀리스

장점

- 모든 엔드포인트(서비스가 접근하는 방법)가 동일한 람다 함수를 사용할 때, 코드는 지속적으로 캐싱되고 시스템에서 콜드 스타트가 거의 일어나지 않는다.
- 하나의 리소스이기 때문에 빠르게 배포할 수 있다.

단점

- 대규모 애플리케이션 경우 각 요청을 처리하기 위해 복잡한 라우팅 시스템을 구축해야 하며, 이것은 아키텍처를 인지할 수 없게 변형될 수 있다.
- 코드 베이스가 지나치게 많은 의존성으로 커지면 단일 실행 성능이 저하된다.
- 디버깅 문제들이 훨씬 더 어려워질 것이다.
- 각 코드마다 고유한 실행이 있기 때문에 메모리 프로비저닝과 시간 제한 설정은 훨씬 어렵다.

### 그래프

장점

- 그래프 쿼리는 모놀리스 접근의 라우팅 매커니즘을 대체할 수 있다.
- 모든 엔드포인트가 동일한 람다 함수를 사용할 때, 코드는 지속적으로 캐싱되고 콜드 스타트는 거의 일어나지 않는다.
- 하나의 함수와 하나의 엔드포인트로 빠른 배포가 가능하다.

단점

- 실행해야 하는 소스코드의 종속성이 너무 많아지는 경우 람다 크기는 성능을 저하시킬 수 있다.
- 각 쿼리마다 고유한 실행이 있기 때문에 메모리 프로비저닝과 시간 제한 설정은 훨씬 어렵다.

### 서로 다른 명명

https://serverless.com/blog/serverless-architecture-code-patterns

# 07 서버리스 데이터베이스의 관리

# 08 서버리스 애플리케이션 보안

### 정보 보안

- 인증(Authentication): 사용자가 자신이 주장하는 사람임을 확인해 신원을 확인하는 속성
- 권한부여(Authorization): 사용자가 요청한 작업을 실행할 수 있는지 결정하는 속성
- 기밀성(Confidentiality): 제3자가 데이터를 이해할 수 없도록 보장하는 속성
- 무결성(Integrity): 감지할 수 없는 변조로부터 메시지를 보호하는 속성
- 부인방지(Non-repudiation): 누군가까 자신의 메시지 진위성을 부정할 수 없도록 보장하는 속성
- 가용성(Availability): 필요할 때 시스템을 사용할 수 있게 하는 속성

# 09 서버리스 알림 처리

# 10 테스트, 배포, 모니터링

### 로컬에서 AWS 서비스 시뮬레이션

- 람다 함수: https://github.com/lambci/docker-lambda
- API 게이트웨이와 람다 함수 https://github.com/dherault/serverless-offline
- 스케쥴된 람다 함수 https://github.com/ajmath/serverless-offline-scheduler
- 다이나모DB https://github.com/mhart/dynalite

### 개발 워크플로우

### 스테이징 환경 생성

- 개발 환경: 코드를 진행중인 작업으로 배포하고 다른 서비스와 함께 작동하는지 테스트한다.
- 스테이징 환경: 일반적으로 고객 또는 품질 보증 팀에 의한 빌드 검증을 위해 필요하다.
- 운영 환경: 최종 사용자가 애플리케이션을 볼 수 있는 곳이다.






